This directory contains sample files that should make it easy to
create an EO algorithm to evolve any type of structure 
(EO comes with two examples, bitstrings and vector of real variables,
so you'll need this qs soon as you want to evolve something else).

At the moment, only algorithms involving a scalar fitness (double)
are implemented (see test dir for Pareto optimization of multiple-
objective fitness - or be patient :-)

This file will help you to build the same algorithm than the ones 
in the Lesson4 of the tutorial, but with YOUR genotype instead of
*bitstrings or vector<double>

It is assumed in the following that you have read the first part of
the tutorial (Lessons 1 to 4).

Creating the algorithm for your genotype
----------------------------------------
In what follows, we will suppose that you want to evolve some data
structure, and that you have enough programming skills to be able to
write C code for its random initilialization, its crossover, its
mutation and the computation of its fitness.

The helper script create.sh will create for you the files you need
from teh examples in tutorial/Templates dir, and all you'll have to do
is to include the actual code where indicated in those files (between
keywords START and END). 

First, let's choose a name: let's call the new EO class eoAppli.
All newly created classes will be named eoApplicationXXX (in the file
eoApplicationXXX)

1- create a directory for your application in the tutorial dir, "parallel" to
the LessonX dirs (though any name can do, of course, we will suppose
its full name, from the / root dir, is APPLICATION in what follows)

2- cd to the tutorial/Templates dir

3- run the helper script create.sh with the following arguments
            create.sh Appli APPLICATION

4- cd to the APPLICATION dir. You should see there the following
files:
   Makefile               with default target eoAppliEA
   eoAppli.h              class eoAppli<FitT>, FitT = template fitness
   eoAppliEA.cpp          the main file, includes all other, to be compiled
   eoAppliEvalFunc.h      class for the computation of fotness
   eoAppliInit.h          class for genotype initlialization
   eoAppliMutation.h      class for mutation 
   eoAppliQuadCrossover.h class for (quadratic) crossover

Note: You can go directly to step 6 and 7: you'll get a lot of
warnings, but will be able to run an EA that does nothing!

5- Edit those files one after the other and add you code where
indicated (look for keywords START and END and modify code in
between).

Note: If your APPLICATION dir is in the tutorial dir, you don't need
to modify Makefile.

6- Compile eoAppliEA.cpp:

               % make

7- Run the resulting program:

               % eoAppliEA

The default output is one line per generation with the generation
number, the number of evaluations performed, the best and average
fitnesses in the population.
The algorithm stops by default after 100 generations.

8- Customize the parameters: copy eoAppliEA.status into
e.g. eoAppliEA.param, edit eoAppliEA.param (uncomment the lines you
want to become active), and run

               % eoAppliEA @eoAppliEA.param

(see the Lesson 4 of the tutorial for more details now).

HINTS
-----

1- All new classes you will create probably require some parameters in
the constructor, and some (if not all) thoses parameters are likele to
be user parameter: you can either read them in the main file (as is
done in the sample eoAppliEA.cpp) or pass the eoParser to the
constructor of the class, and read the parameter from the parser.

2- If you stick to privacy for the data in your EO class, you will
probably need to write accessors to those data, as well as some public
methods to modify them.

3- The sample eoAppliEA.cpp supposes that you ony have one crossover
and one mutation operator. However, the code for multiple operators
is there: you can have for instance 2 crossover operators, and choose
among them according to relative weights (proportional choice) - same
for mutation. Look at the operator section in eoAppliEA.cpp
In particular, the user parameter mutationRate is totally useless for
a single operator, and is there only as a provision for using more
than one.

To add another operator, you have to create another class by mimicking
what has been done for the first operator.
For instance, let's suppose you want to create another mutation.

* duplicate the code for eoAppliMutation class 
* in the second version, change the class name (eoAppliMutation) into
another name (let's say eoAppliBetterMutation) - you must change the
name in the class declaration, in the constructor and in the
className() method.
* in the new eoAppliBetterMutation class, change the code for the
operator() - and eventually the code for the constructor.
* in the eoAppliEA.cpp file, in the mutation section, uncomment the
lines 
      eoMyStructSecondMutation<Indi> mut2(varType  _anyVariable);
      double mut2Rate = parser.createParam(1.0, "mut2Rate", "Relative rate for mutation 2", '2', "Variation Operators").value(); 
       propMutation.add(mut2, mut2Rate); 

and change the name of the class from eoAppliSecondMutation to your
name eoAppliBetterMutation (you can also change the keyword from
mut2Rate to something more meaningful like BetterMutationRate).
You're done!
